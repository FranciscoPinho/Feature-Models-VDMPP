class FeatureModel
types
-- TODO Define types here
values
-- TODO Define values here
instance variables
public featureTree : set of Feature := {};
private rootName : Feature`FeatureName;
--Invariants
 -- cant have duplicate features
 -- root feature cannot be named root - reserved word
inv not exists f1,f2 in set featureTree & f1.name=f2.name and f1<>f2;


-- CHECKS WHEN ADDING SUBFEATURES
 -- a feature cannot be a subfeature of more than one feature(excluding in requires and excludes relationships)
--inv forall f1,f2 in set featureTree & f1.getSubFeatures() <> f2.getSubFeatures();
-- cannot add a subfeature sf to feature F if F already implies or requires said feature
-- call F.notRequiredExcluded(sf)
-- cannot require or exclude a feature f1 to F if it's already a subfeature of F	
--call F.notSubFeature(f1)

operations
--Constructor
  public FeatureModel: Feature`FeatureName ==> FeatureModel
  FeatureModel(root) == (
  addFeature(root);
  rootName:=root;
  return self
  )
  pre root<>""
  post card featureTree = 1;
--Selector  
  public get: Feature`FeatureName ==> Feature
  get(fname) == 
  (
  	return iota x in set featureTree & x.name=fname
  );
--Add Features to featureTree  
  public addFeature: Feature`FeatureName ==> ()
  addFeature(fname) == 
  (
  	dcl f: Feature :=new Feature(fname);
  	featureTree := featureTree union {f}
  ) 
  post card featureTree = card featureTree~ + 1;
  
  --Add Subfeatures to a feature
  public addMandatorySub: Feature`FeatureName*Feature`FeatureName ==> ()
  addMandatorySub(newF,targetF) == 
  (
  	addFeature(newF);
		get(targetF).addMandatory(get(newF));
		get(newF).setParent(targetF);
		calcIndegree(get(newF))
  ) 
 	pre exists f1 in set featureTree & f1.name=targetF;
 	
 	public addOptionalSub: Feature`FeatureName*Feature`FeatureName ==> ()
  addOptionalSub(newF,targetF) == 
  (
  	addFeature(newF);
		get(targetF).addOptional(get(newF));
		get(newF).setParent(targetF);
		calcIndegree(get(newF))
  ) 
 	pre exists f1 in set featureTree & f1.name=targetF;
 	
 	public addOrSub: Feature`FeatureName*Feature`FeatureName ==> ()
  addOrSub(newF,targetF) == 
  (
  	addFeature(newF);
		get(targetF).addOr(get(newF));
		get(newF).setParent(targetF);
		calcIndegree(get(newF))
  ) 
 	pre exists f1 in set featureTree & f1.name=targetF;
  
  public addXorSub: Feature`FeatureName*Feature`FeatureName ==> ()
  addXorSub(newF,targetF) == 
  (
  	addFeature(newF);
		get(targetF).addXor(get(newF));
		get(newF).setParent(targetF);
		calcIndegree(get(newF))
  ) 
 	pre exists f1 in set featureTree & f1.name=targetF;
 
 	-- requires and excludes relationships
 public requires: Feature`FeatureName*Feature`FeatureName ==> ()
  requires(requiree,requirer) == 
  (
		get(requirer).addRequire(get(requiree))
  ) 
 	pre exists f1,f2 in set featureTree & f1<>f2 and f1.name=requirer and f2.name=requiree
 	post card featureTree=card featureTree~;
 	
 public excludes: Feature`FeatureName*Feature`FeatureName ==> ()
  excludes(excludee,excluder) == 
  (
		get(excluder).addRequire(get(excludee))
  ) 
 	pre exists f1,f2 in set featureTree & f1<>f2 and f1.name=excluder and f2.name=excludee
 	post card featureTree=card featureTree~;
 	
 	--Indegree calculations
 	public calcIndegree: Feature ==> ()
  calcIndegree(feature) == 
  (
			if(feature.parent=rootName)
			then feature.incIndegree()
		 	else
		 	(
		 		calcIndegreeAux(get(feature.parent),feature)
		 	)
  ); 
  
	public calcIndegreeAux: Feature*Feature ==> ()
  calcIndegreeAux(parentF,original) == 
  (
  		original.incIndegree();
			if(parentF.parent=rootName)
			then original.incIndegree()
		 	else
		 	(
		 		calcIndegreeAux(get(parentF.parent),original)
		 	)
  );
  
end FeatureModel