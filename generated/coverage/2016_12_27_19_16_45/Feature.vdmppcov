class Feature
types

public FeatureName = seq1 of char;

values
-- TODO Define values here
instance variables
private true_self: Feature;
public optional : set of Feature := {};
public mandatory : set of Feature := {};
public orGroup : set of set of Feature :={};
public xorGroup : set of set of Feature :={};
public requires : set of Feature :={};
public excludes : set of Feature :={};
public name : FeatureName;

--inv a feature cant contain itself in any of these sets
--inv a feature cannot have duplicate subfeatures

inv true_self not in set optional union mandatory union requires union excludes union dunion{orGroup,xorGroup};
inv not exists f1,f2 in set optional union mandatory union dunion{orGroup,xorGroup} & f1=f2;

operations
-- create feature object with desired name
public Feature : FeatureName ==> Feature
	Feature(nm) == (
		name := nm;
		true_self := self;
		return self
	);
-- return set of all subfeatures in mandatory,optional,orgroup e xorgroup
public getSubFeatures: () ==> set of Feature
	getSubFeatures() == return self.mandatory union self.optional union dunion{self.orGroup,self.xorGroup}
	post true_self=true_self~;
	
-- a feature cannot require  or exclude it's own subfeatures	
public checkSubIntegrity: () ==> bool
  checkSubIntegrity() == return {f|f in set (self.getSubFeatures() inter (requires union excludes))}={}
 	post true_self=true_self~;

functions



traces
-- TODO Define Combinatorial Test Traces here
end Feature