class FeatureModel
types
public Configuration = set of Feature;
values
-- TODO Define values here
instance variables
public featureTree : set of Feature := {};
private rootName : Feature`FeatureName;
public allValidConfigurations : set of Configuration := {};
--Invariants
 -- cant have duplicate features
inv not exists f1,f2 in set featureTree & f1.name=f2.name and f1<>f2;

operations
--Constructor
  public FeatureModel: Feature`FeatureName ==> FeatureModel
  FeatureModel(root) == (
  addFeature(root);
  rootName:=root;
  return self
  )
  pre root<>""
  post card featureTree = 1;
--Selector  
  public get: Feature`FeatureName ==> Feature
  get(fname) == 
  (
  	return iota x in set featureTree & x.name=fname
  );
--Add Features to featureTree  
  public addFeature: Feature`FeatureName ==> ()
  addFeature(fname) == 
  (
  	dcl f: Feature :=new Feature(fname);
  	featureTree := featureTree union {f}
  ) 
  post card featureTree = card featureTree~ + 1;
  
  --Add Subfeatures to a feature
  public addMandatorySub: Feature`FeatureName*Feature`FeatureName ==> ()
  addMandatorySub(newF,targetF) == 
  (
  	addFeature(newF);
		get(targetF).addMandatory(get(newF));
		get(newF).setParent(targetF);
		calcIndegree(get(newF));
  ) 
 	pre exists f1 in set featureTree & f1.name=targetF;
 	
 	public addOptionalSub: Feature`FeatureName*Feature`FeatureName ==> ()
  addOptionalSub(newF,targetF) == 
  (
  	addFeature(newF);
		get(targetF).addOptional(get(newF));
		get(newF).setParent(targetF);
		calcIndegree(get(newF))
  ) 
 	pre exists f1 in set featureTree & f1.name=targetF;
 	
 	public addOrSub: Feature`FeatureName*Feature`FeatureName ==> ()
  addOrSub(newF,targetF) == 
  (
  	addFeature(newF);
		get(targetF).addOr(get(newF));
		get(newF).setParent(targetF);
		calcIndegree(get(newF))
  ) 
 	pre exists f1 in set featureTree & f1.name=targetF;
  
  public addXorSub: Feature`FeatureName*Feature`FeatureName ==> ()
  addXorSub(newF,targetF) == 
  (
  	addFeature(newF);
		get(targetF).addXor(get(newF));
		get(newF).setParent(targetF);
		calcIndegree(get(newF))
  ) 
 	pre exists f1 in set featureTree & f1.name=targetF;
 
 	-- requires and excludes relationships
 public requires: Feature`FeatureName*Feature`FeatureName ==> ()
  requires(requiree,requirer) == 
  (
		get(requirer).addRequire(get(requiree))
  ) 
 	pre exists f1,f2 in set featureTree & f1<>f2 and f1.name=requirer and f2.name=requiree
 	post card featureTree=card featureTree~;
 	
 public excludes: Feature`FeatureName*Feature`FeatureName ==> ()
  excludes(excludee,excluder) == 
  (
  	if(excludee not in set get(rootName).mandatory)
		then get(excluder).addExclude(get(excludee));
  ) 
 	pre exists f1,f2 in set featureTree & f1<>f2 and f1.name=excluder and f2.name=excludee
 	post card featureTree=card featureTree~;
 	
 	public removeExcludes: Feature`FeatureName*Feature`FeatureName ==> ()
  	removeExcludes(excludee,excluder) == 
  	(
  		if(get(excludee) in set get(excluder).excludes)
				then get(excluder).removeExclude(get(excludee))
				else return;
  	) 
 		pre exists f1,f2 in set featureTree & f1<>f2 and f1.name=excluder and f2.name=excludee;
 		
 	public removeRequires: Feature`FeatureName*Feature`FeatureName ==> ()
  	removeRequires(requiree,requirer) == 
  	(
  		if(get(requiree) in set get(requirer).requires)
				then get(requirer).removeRequire(get(requiree))
				else return;
  	) 
 		pre exists f1,f2 in set featureTree & f1<>f2 and f1.name=requirer and f2.name=requiree;	

 	--Indegree calculations
 	public calcIndegree: Feature ==> ()
  	calcIndegree(feature) == 
  	(
			if(feature.parent=rootName)
			then feature.incIndegree()
		 	else
		 	(
		 		calcIndegreeAux(get(feature.parent),feature)
		 	)
  	); 
  
	public calcIndegreeAux: Feature*Feature ==> ()
  	calcIndegreeAux(parentF,original) == 
  	(
  		original.incIndegree();
			if(parentF.parent=rootName)
			then original.incIndegree()
		 	else
		 	(
		 		calcIndegreeAux(get(parentF.parent),original)
		 	)
  	);
	
	
  --Make configuration
  public generateValidConfigs: () ==> ()
  	generateValidConfigs() == 
  	(
  	
 		 		dcl config : Configuration := {};
 		 		config := config union {get(rootName)};
 		 		--for all subfeatures of root?
 		 		--switch case for kind of subfeature
 		 		-- config := dunion{config,{get(rootName)}}; OBSOLETE BY ABOVE MAYBE
 				printConfiguration(config);
 		 		--generateValidConfigsAux()
 		 		--if(checkConstraints()) then allValidConfigurations := allValidConfigurations union {config};
 	 );
 
  --generateValidConfigsAux
  public checkConstraints: Configuration*set of Feature ==> bool
  	checkConstraints(config,mustRequire)==
  	(
  		-- not a valid configuration until required features are in the configuration
  		if(mustRequire subset config=false)
  		then return false;
  		-- cannot exclude features that are already in the configuration
  		for all f in set config 
  		do
  		( 
  			if(f.excludes inter config <> {})
  				then return false;
  		);
  		-- if all constraints are respected it's a valid configuration
  		return true;
  	);
  

 
	--printing utilities 
  public printConfiguration: Configuration ==> ()
  	printConfiguration(config)==
  	(
  		for all f in set config 
  		do (
  		IO`println("-----Current Configuration-----");
  		IO`println(f.name);
  		IO`println("-----End of Current Configuration-----");
  		);	
  	 );
  
  public printAllConfigurations: () ==> ()
  	printAllConfigurations()==
  	(
  		for all f in set allValidConfigurations 
  		do (
  			printConfiguration(f);
  		);	
  	 );
  	 		
end FeatureModel